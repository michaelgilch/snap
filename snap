#!/bin/bash
#
# Window Snapping Utility for Openbox
#
# Makes some assumptions about multi-monitor setups:
# - screens arranged horizontally
# - screens have same resolutions
# - panels are present on every screen, in the same location, and of the same size

# For unassigned variables in get_window_geometry()
# shellcheck disable=SC2154


WINDOW=0
NUM_MONITORS=0
DIRECTION=""

function usage() {
    echo "Syntax: snap [l|r|u|d]"
    echo "  l  snap left"
    echo "  r  snap right"
    echo "  u  snap up"
    echo "  d  snap down"
    echo 
}

# Sets NUM_MONITORS
function get_monitor_count() {
    NUM_MONITORS=$(xrandr -q | grep -c " connected")
    echo "Num Monitors: $NUM_MONITORS"
}

# Gets the Screen Geometries
#   SCREEN_X_START  starting X coordinate of the primary monitor, not including panels and docks
#   SCREEN_Y_START  starting Y coordinate of the primary monitor, not including panels and docks
#   SCREEN_WIDTH    usable width of each screen, not including panels and docks
#   SCREEN_HEIGHT   usable height of each screen, not including panels and docks
function get_desktop_geometry() {

    # _NET_WORKAREA contains the starting x coordinate, starting y coordinate, width, and height
    # of each desktop workspace.
    # Docks and Panels are taken into account with all 4 values, not including their sizes as 
    # usable realestate.
    # All desktop workspaces should have the same geometries, as far as I know, so we only need
    # the first set of measurements.
    desktop_geom_qry_results=$(xprop -root _NET_WORKAREA | sed 's/,//g' | cut -d' ' -f3-)

    SCREEN_X_START=$(echo "$desktop_geom_qry_results" | cut -d' ' -f1)
    SCREEN_Y_START=$(echo "$desktop_geom_qry_results" | cut -d' ' -f2)
    desktop_width=$(echo "$desktop_geom_qry_results" | cut -d' ' -f3)
    SCREEN_WIDTH=$((desktop_width/NUM_MONITORS))
    SCREEN_HEIGHT=$(echo "$desktop_geom_qry_results" | cut -d' ' -f4)
    
    echo "Desktop Geometry:"
    echo "  X Start: $SCREEN_X_START"
    echo "  Y Start: $SCREEN_Y_START"
    echo "  Width:   $SCREEN_WIDTH"
    echo "  Height:  $SCREEN_HEIGHT"
}

# Sets WINDOW to the active window ID
function get_active_window() {
    WINDOW=$(xdotool getactivewindow)
    echo "Active Window: $WINDOW"
}

# Determines if window has already been snapped and sets original geometries
#   ORIG_X      original unsnapped X position
#   ORIG_Y      original unsnapped Y position
#   ORIG_W      original unsnapped width
#   ORIG_H      original unsnapped height
#   LAST_X
#   LAST_Y
#   LAST_W
#   LAST_H
#   LAST_X_QUAD
#   LAST_Y_QUAD
function get_window_state() {
    xprop -id "$WINDOW" | grep "_SNAP_STATE" >/dev/null
    # shellcheck disable=SC2181
    if [ $? == 0 ]; then
        echo "Window is already snapped."
        # _SNAP_STATE stores original x, y, w, h, last x/y quadrant, and the last x, y, w, and h.
        window_state=$(xprop -id "$WINDOW" _SNAP_STATE | sed 's/,//g' | cut -d' ' -f3-)

        ORIG_X=$(echo "$window_state" | cut -d' ' -f1)
        ORIG_Y=$(echo "$window_state" | cut -d' ' -f2)
        ORIG_W=$(echo "$window_state" | cut -d' ' -f3)
        ORIG_H=$(echo "$window_state" | cut -d' ' -f4)
        LAST_X_QUAD=$(echo "$window_state" | cut -d' ' -f5)
        LAST_Y_QUAD=$(echo "$window_state" | cut -d' ' -f6)
        LAST_X=$(echo "$window_state" | cut -d' ' -f7)
        LAST_Y=$(echo "$window_state" | cut -d' ' -f8)
        LAST_W=$(echo "$window_state" | cut -d' ' -f9)
        LAST_H=$(echo "$window_state" | cut -d' ' -f10)
    else
        echo "Window is not yet snapped."
        ORIG_X=$CURR_X
        ORIG_Y=$CURR_Y
        ORIG_W=$CURR_W
        ORIG_H=$CURR_H
        LAST_X_QUAD=0
        LAST_Y_QUAD=0
    fi
}

function get_window_monitor() {
    monitor=1
    
    if [ "$ORIG_X" -ge "$SCREEN_WIDTH" ]; then
        monitor=2
    fi
}

# Gets the current geometry of the Window
#   CURR_X  current window X position  
#   CURR_Y  current window Y position
#   CURR_W  current window width
#   CURR_H  current window height
function get_window_geometry() {
    # The most accurate representation of X and Y coordinates I could find is using 
    # xwininfo and calculating based off the absolute and relative positions.
    eval "$(xwininfo -id "$WINDOW" |
            sed -n -e "s/^ \+Absolute upper-left X: \+\([0-9]\+\).*/x=\1/p" \
                   -e "s/^ \+Absolute upper-left Y: \+\([0-9]\+\).*/y=\1/p" \
                   -e "s/^ \+Relative upper-left X: \+\([0-9]\+\).*/a=\1/p" \
                   -e "s/^ \+Relative upper-left Y: \+\([0-9]\+\).*/b=\1/p" \
                   -e "s/^ \+Width: \+\([0-9]\+\).*/w=\1/p" \
                   -e "s/^ \+Height: \+\([0-9]\+\).*/h=\1/p" )"
    
    echo "Current Window Geometry:"
    echo "  Abs X:   $x"
    echo "  Abs Y:   $y"
    echo "  Rel X:   $a"
    echo "  Rel Y:   $b"
    echo "  Width:   $w"
    echo "  Height:  $h"

    # The actual X and Y coordinates of the window need to be calculated by subtracting
    # the relative X and Y coordinates from the Absolute X and Y coordinates.
    CURR_X=$((x-a))
    CURR_Y=$((y-b))

    CURR_W=$w
    CURR_H=$h

    echo "Calcuated Window Geometry:"
    echo "  Curr X:  $CURR_X"
    echo "  Curr Y:  $CURR_Y"
    echo "  Curr W:  $CURR_W"
    echo "  Curr H:  $CURR_H"
}

# Gets the window borders
#   BORDER_LEFT     the left border size
#   BORDER_RIGHT    the right border size
#   BORDER_TOP      the top border size, including titlebar if existant
#   BORDER_BOTTOM   the bottom border size
function get_window_borders() {
    # _NET_FRAME_EXTENTS contains the left, right, top, and bottom borders, in that order
    window_frame=$(xprop -id "$WINDOW" _NET_FRAME_EXTENTS | sed 's/,//g' | cut -d' ' -f3-)

    BORDER_LEFT=$(echo "$window_frame" | cut -d' ' -f1)
    BORDER_RIGHT=$(echo "$window_frame" | cut -d' ' -f2)
    BORDER_TOP=$(echo "$window_frame" | cut -d' ' -f3)
    BORDER_BOTTOM=$(echo "$window_frame" | cut -d' ' -f4)

    echo "Window Frame Geometry:"
    echo "  Left:   $BORDER_LEFT"
    echo "  Right:  $BORDER_RIGHT"
    echo "  Top:    $BORDER_TOP"
    echo "  Bottom: $BORDER_BOTTOM"
}

function remove_stored_geometry() {
    echo "Removing xprop _SNAP_STATE"
    xprop -id "$WINDOW" -remove _SNAP_STATE
}

if [ $# -eq 0 ] || [ $# -gt 1 ]; then
   usage
   exit
fi

case $1 in
    l|r|u|d) DIRECTION="$1"
        ;;
    *)
        usage; exit
        ;;
esac

get_active_window

get_monitor_count
get_desktop_geometry

get_window_geometry
get_window_borders
get_window_state
get_window_monitor


new_x_quad=$LAST_X_QUAD
new_y_quad=$LAST_Y_QUAD

if [ "$DIRECTION" == 'l' ]; then
    new_x_quad=$((LAST_X_QUAD-1))
elif [ "$DIRECTION" == 'r' ]; then
    new_x_quad=$((LAST_X_QUAD+1))
elif [ "$DIRECTION" == 'u' ]; then
    new_y_quad=$((LAST_Y_QUAD+1))
elif [ "$DIRECTION" == 'd' ]; then
    new_y_quad=$((LAST_Y_QUAD-1))
fi

if [ "$new_x_quad" -gt 1 ] || [ "$new_x_quad" -lt -1 ]; then
    new_x_quad=$LAST_X_QUAD
    echo "x out of range"
fi

if [ "$new_y_quad" -gt 1 ] || [ "$new_y_quad" -lt -1 ]; then
    new_y_quad=$LAST_Y_QUAD
    echo "y out of range"
fi

if [ "$new_x_quad" -eq 0 ] && [ "$new_y_quad" -eq 0 ]; then
    echo "Returning to original position"
    new_x=$ORIG_X
    new_y=$ORIG_Y
    new_w=$ORIG_W
    new_h=$ORIG_H
    
    remove_stored_geometry
else
    case $new_x_quad in
        -1)
            new_x=$SCREEN_X_START
            new_w=$((SCREEN_WIDTH/2-BORDER_LEFT-BORDER_RIGHT))
            ;;
        0)
            new_x=$SCREEN_X_START
            new_w=$((SCREEN_WIDTH-BORDER_LEFT-BORDER_RIGHT))
            ;;
        1)
            # new_x=$((SCREEN_WIDTH/2+1))
            new_x=$((SCREEN_WIDTH/2))
            new_w=$((SCREEN_WIDTH/2-BORDER_LEFT-BORDER_RIGHT))
            ;;
    esac
    
    case $new_y_quad in 
        -1)
            new_y=$((SCREEN_HEIGHT/2+BORDER_TOP+BORDER_BOTTOM+1))
            new_h=$((SCREEN_HEIGHT/2-BORDER_TOP-BORDER_BOTTOM))
            ;;
        0)
            new_y=$SCREEN_Y_START
            new_h=$((SCREEN_HEIGHT-BORDER_TOP-BORDER_BOTTOM-1))
            ;;
        1)
            new_y=$SCREEN_Y_START
            new_h=$((SCREEN_HEIGHT/2-BORDER_TOP-BORDER_BOTTOM))
            ;;
    esac
    
    get_window_monitor

    if [ "$monitor" == 2 ]; then
        new_x=$((new_x+SCREEN_WIDTH))
    fi

    xprop -id "$WINDOW" -f _SNAP_STATE 32i -set _SNAP_STATE "$ORIG_X, $ORIG_Y, $ORIG_W, $ORIG_H, $new_x_quad, $new_y_quad, $new_x, $new_y, $new_w, $new_h"
fi

echo "Snapping to:"
echo "  Quadrant: $new_x_quad, $new_y_quad"
echo "  New X:    $new_x"
echo "  New Y:    $new_y"
echo "  New W:    $new_w"
echo "  New H:    $new_h"
    
xdotool windowmove "$WINDOW" "$new_x" "$new_y"
xdotool windowsize "$WINDOW" "$new_w" "$new_h"

get_window_geometry
